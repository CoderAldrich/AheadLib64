#include "StdAfx.h"
#include "PeAnalyse.h"
#include <Shlwapi.h>
#pragma comment(lib,"Shlwapi.lib")

PeAnalyse::PeAnalyse(string strPath)
{
	strFilePath = strPath;
	g_hFile = INVALID_HANDLE_VALUE;
	g_hMapping = INVALID_HANDLE_VALUE;
	g_ImageBase = NULL;
}

PeAnalyse::~PeAnalyse(void)
{
	if (g_ImageBase !=NULL)
	{
		UnmapViewOfFile(g_ImageBase);
	}
	if (g_hMapping !=INVALID_HANDLE_VALUE)
	{
		CloseHandle(g_hMapping);
	}
	if (g_hFile !=INVALID_HANDLE_VALUE)
	{
		CloseHandle(g_hFile);		
	}
}


BOOL PeAnalyse::LoadPEFile()
{
		/*hFile=CreateFile(lpFilename,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
	if (hFile==INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}
	pstMapFile->dwFileSize=::GetFileSize(hFile,NULL);
	hMapping=CreateFileMapping(hFile,0,PAGE_READONLY|SEC_COMMIT|SEC_IMAGE,0,pstMapFile->dwFileSize,0);
	if (hMapping==NULL)
	{
		DWORD dwError=GetLastError();
		CloseHandle(hFile);
		return FALSE;
	}*/
	g_hFile=CreateFile(strFilePath.c_str(),GENERIC_READ|GENERIC_WRITE,FILE_SHARE_READ,NULL,OPEN_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,NULL);
	if (g_hFile==INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}
	DWORD dwFileSize=GetFileSize(g_hFile,NULL);
	g_hMapping=CreateFileMapping(g_hFile,NULL,PAGE_READWRITE|SEC_COMMIT/* SEC_IMAGE*/,0,dwFileSize,NULL);
	if (g_hMapping==NULL)
	{
		CloseHandle(g_hFile);
		return FALSE;
	}
	g_ImageBase=MapViewOfFile(g_hMapping,FILE_MAP_ALL_ACCESS,0,0,0);
	if (g_ImageBase==NULL)
	{
		CloseHandle(g_hMapping);
		CloseHandle(g_hFile);
		return FALSE;
	}
	return TRUE;
}

DWORD PeAnalyse::RavToPtr(DWORD dwRva)
{
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)g_ImageBase;
	PIMAGE_NT_HEADERS64 pNtHeader64 = (PIMAGE_NT_HEADERS64)((DWORD)g_ImageBase+pDosHeader->e_lfanew);
	PIMAGE_OPTIONAL_HEADER64 pOptHeader64 = (PIMAGE_OPTIONAL_HEADER64)(&(pNtHeader64->OptionalHeader));

	//转到文件偏移
	int iSectionCount = pNtHeader64->FileHeader.NumberOfSections;
	int iSecIndex;//所在的区段索引
	PIMAGE_SECTION_HEADER pSecHeader = NULL;//所在的区段指针
	for (iSecIndex=0;iSecIndex<iSectionCount;iSecIndex++)
	{
		PIMAGE_SECTION_HEADER pTempSectionHeader=IMAGE_FIRST_SECTION(pNtHeader64)+iSecIndex;
		if(pTempSectionHeader->VirtualAddress<=dwRva && dwRva< (pTempSectionHeader->VirtualAddress+pTempSectionHeader->SizeOfRawData))
		{
			pSecHeader = pTempSectionHeader;
			break;
		}
	}
	DWORD dwVRk=pSecHeader->VirtualAddress-pSecHeader->PointerToRawData;
	return (DWORD)(g_ImageBase)+dwRva-dwVRk;

}

BOOL PeAnalyse::ListExportFunc()
{
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)g_ImageBase;
	if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE)
	{
		cout<<"--Not valid PE"<<endl;
		return FALSE;
	}
	PIMAGE_NT_HEADERS64 pNtHeader64 = (PIMAGE_NT_HEADERS64)((DWORD)g_ImageBase+pDosHeader->e_lfanew);
	if (pNtHeader64->Signature != IMAGE_NT_SIGNATURE)
	{
		cout<<"--Not valid PE"<<endl;
		return FALSE;
	}

	if ((pNtHeader64->FileHeader.Characteristics & IMAGE_FILE_DLL) == 0) //0x2000  : File is a DLL
	{
		cout<<"--Not a Dll File"<<endl;
		return FALSE;
	}


	PIMAGE_OPTIONAL_HEADER64 pOptHeader64 = (PIMAGE_OPTIONAL_HEADER64)(&(pNtHeader64->OptionalHeader));
	DWORD dwExportRva = (pOptHeader64->DataDirectory[0].VirtualAddress);

	DWORD dwExportAddr = RavToPtr(dwExportRva);
	PIMAGE_EXPORT_DIRECTORY pExportDir=(PIMAGE_EXPORT_DIRECTORY)dwExportAddr;
	DWORD dwNumOfFunc=pExportDir->NumberOfFunctions;	
	//按序号遍历
	DWORD dwFuncTableAddr = RavToPtr(pExportDir->AddressOfFunctions);
	DWORD dwFuncNameTable = RavToPtr(pExportDir->AddressOfNames); 
	DWORD dwBase = pExportDir->Base;//起始序号 一般为1
	for(int m=0;m<dwNumOfFunc;m++)
	{
		DWORD dwTmpFuncAddr = ((PDWORD)(dwFuncTableAddr))[m];
		//m在AddressOfNameOrdinals中的索引 然后就是AddressOfNames的索引，当然一般都是顺序来的
		int dwTmp=-1;
		for(int n = 0;n<pExportDir->NumberOfNames;n++)
		{
			if (((WORD*)RavToPtr(pExportDir->AddressOfNameOrdinals))[n]==m)
			{
				//n到AddressOfNames 找到对应的导出名字，如果没有就是只按序号导出的
				dwTmp = n;
				break;
			}
		}
		if (dwTmp==-1)//没有导出名称
		{
			printf("--序号:%02d  地址:%08x 函数名:无\n",dwBase+m,dwTmpFuncAddr);
			FUNCINFO fiTmp;
			fiTmp.strFuncName = "NoName";
			fiTmp.dwFuncXuhao = dwBase+m;
			m_FuncArray.push_back(fiTmp);
		}
		else
		{
			char *pFuncName = (char*)RavToPtr(((PDWORD)(dwFuncNameTable))[dwTmp]);
			printf("--序号:%02d  地址:%08x 函数名:%s\n",dwBase+m,dwTmpFuncAddr,pFuncName);
			FUNCINFO fiTmp;
			fiTmp.strFuncName = pFuncName;
			fiTmp.dwFuncXuhao = dwBase+m;
			m_FuncArray.push_back(fiTmp);
		}
	}
	return TRUE;
}

BOOL PeAnalyse::WriteCppFile()
{
	string strOut = strFilePath;
	int nIndex = strOut.rfind('\\');
	strOut.erase(nIndex);
	strOut += "\\dllmain.cpp";
	


	FILE *fp = fopen(strOut.c_str(),"wb+");
	if (fp==NULL)
	{
		printf("--open file failed\n");
		return FALSE;
	}

	char * szBanner = "Generated by  AheadLib4x64 v1.0 ----by:W1nds";
	fprintf(fp,""
		);


	fprintf(fp,
		"// %s\r\n\r\n"
		"#include \"stdafx.h\"\r\n#include <Windows.h>\r\n#include <tchar.h>\r\n\r\nVOID InitAddr();\r\n\r\n\r\n",
		szBanner);

	
	vector<FUNCINFO>::iterator it;

	for (it=m_FuncArray.begin();it!=m_FuncArray.end();it++)
	{	
		char szTmp[1024] = {0};
		if(it->strFuncName == "NoName")
		{
			wsprintfA(szTmp,"#pragma comment(linker, \"/EXPORT:Noname%d=_AheadLib_Noname%d,@%d,NONAME\")\r\n",it->dwFuncXuhao,\
				it->dwFuncXuhao,it->dwFuncXuhao);	
		}
		else
		{
			wsprintfA(szTmp,"#pragma comment(linker, \"/EXPORT:%s=_AheadLib_%s,@%d\")\r\n",it->strFuncName.c_str(),it->strFuncName.c_str(),\
			it->dwFuncXuhao);
		}
		fwrite(szTmp,strlen(szTmp),1,fp);
	}
	string strDllName = PathFindFileName(strFilePath.c_str());
	
	
	string strTmp="// 宏定义\r\n";
	strTmp=strTmp+"#define EXTERNC extern \"C\"\r\n";
	strTmp=strTmp+"#define NAKED __declspec(naked)\r\n";
	strTmp=strTmp+"#define EXPORT __declspec(dllexport)\r\n";
	strTmp=strTmp+"\r\n";
	strTmp=strTmp+"#define ALCPP EXPORT NAKED\r\n";
	strTmp=strTmp+"#define ALSTD EXTERNC EXPORT NAKED void __stdcall\r\n";
	strTmp=strTmp+"#define ALCFAST EXTERNC EXPORT NAKED void __fastcall\r\n";
	strTmp=strTmp+"#define ALCDECL EXTERNC  void __cdecl\r\n";
	strTmp=strTmp+"////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n";

	strTmp= strTmp+"// AheadLib 命名空间";
	strTmp=strTmp+"\r\nnamespace AheadLib";
	strTmp=strTmp+"\r\n{";
	strTmp=strTmp+"\r\n	HMODULE m_hModule = NULL;	// 原始模块句柄";
	strTmp=strTmp+"\r\n	DWORD m_dwReturn[155] = {0};	// 原始函数返回地址";
	strTmp=strTmp+"\r\n";
	strTmp=strTmp+"\r\n";
	strTmp=strTmp+"\r\n	// 加载原始模块";
	strTmp=strTmp+"\r\n	inline BOOL WINAPI Load()";
	strTmp=strTmp+"\r\n	{";
	strTmp=strTmp+"\r\n		TCHAR tzPath[MAX_PATH];";
	strTmp=strTmp+"\r\n		TCHAR tzTemp[MAX_PATH * 2];";
	strTmp=strTmp+"\r\n";
	strTmp=strTmp+"\r\n		GetSystemDirectory(tzPath, MAX_PATH);";
	strTmp=strTmp+"\r\n		lstrcat(tzPath, TEXT(\"\\\\"+ strDllName +"\"));";
	strTmp=strTmp+"\r\n		m_hModule = LoadLibrary(tzPath);";
	strTmp=strTmp+"\r\n		if (m_hModule == NULL)";
	strTmp=strTmp+"\r\n		{";
	strTmp=strTmp+"\r\n			wsprintf(tzTemp, TEXT(\"无法加载 %s，程序无法正常运行。\"), tzPath);";
	strTmp=strTmp+"\r\n			MessageBox(NULL, tzTemp, TEXT(\"AheadLib\"), MB_ICONSTOP);";
	strTmp=strTmp+"\r\n		}";
	strTmp=strTmp+"\r\n";
	strTmp=strTmp+"\r\n		return (m_hModule != NULL);	";
	strTmp=strTmp+"\r\n	}";
	strTmp=strTmp+"\r\n		";
	strTmp=strTmp+"\r\n	// 释放原始模块";
	strTmp=strTmp+"\r\n	inline VOID WINAPI Free()";
	strTmp=strTmp+"\r\n	{";
	strTmp=strTmp+"\r\n		if (m_hModule)";
	strTmp=strTmp+"\r\n		{";
	strTmp=strTmp+"\r\n			FreeLibrary(m_hModule);";
	strTmp=strTmp+"\r\n		}";
	strTmp=strTmp+"\r\n	}";
	strTmp=strTmp+"\r\n";
	strTmp=strTmp+"\r\n	// 获取原始函数地址";
	strTmp=strTmp+"\r\n	FARPROC WINAPI GetAddress(PCSTR pszProcName)";
	strTmp=strTmp+"\r\n	{";
	strTmp=strTmp+"\r\n		FARPROC fpAddress;";
	strTmp=strTmp+"\r\n		CHAR szProcName[16];";
	strTmp=strTmp+"\r\n		TCHAR tzTemp[MAX_PATH];";
	strTmp=strTmp+"\r\n";
	strTmp=strTmp+"\r\n		if (m_hModule == NULL)";
	strTmp=strTmp+"\r\n		{";
	strTmp=strTmp+"\r\n			if (Load() == FALSE)";
	strTmp=strTmp+"\r\n			{";
	strTmp=strTmp+"\r\n				ExitProcess(-1);";
	strTmp=strTmp+"\r\n			}";
	strTmp=strTmp+"\r\n		}";
	strTmp=strTmp+"\r\n";
	strTmp=strTmp+"\r\n		fpAddress = GetProcAddress(m_hModule, pszProcName);";
	strTmp=strTmp+"\r\n		if (fpAddress == NULL)";
	strTmp=strTmp+"\r\n		{";
	strTmp=strTmp+"\r\n			if (HIWORD(pszProcName) == 0)";
	strTmp=strTmp+"\r\n			{";
	strTmp=strTmp+"\r\n				wsprintfA(szProcName, \"%d\", pszProcName);";
	strTmp=strTmp+"\r\n				pszProcName = szProcName;";
	strTmp=strTmp+"\r\n			}";
	strTmp=strTmp+"\r\n";
	strTmp=strTmp+"\r\n			wsprintf(tzTemp, TEXT(\"无法找到函数 %hs，程序无法正常运行。\"), pszProcName);";
	strTmp=strTmp+"\r\n			MessageBox(NULL, tzTemp, TEXT(\"AheadLib\"), MB_ICONSTOP);";
	strTmp=strTmp+"\r\n			ExitProcess(-2);";
	strTmp=strTmp+"\r\n		}";
	strTmp=strTmp+"\r\n";
	strTmp=strTmp+"\r\n		return fpAddress;";
	strTmp=strTmp+"\r\n	}";
	strTmp=strTmp+"\r\n}";
	strTmp=strTmp+"\r\nusing namespace AheadLib;";
	strTmp=strTmp+"\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////";
	
	strTmp=strTmp+"\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////";
	strTmp=strTmp+"\r\n// 入口函数";
	strTmp=strTmp+"\r\nBOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)";
	strTmp=strTmp+"\r\n{";
	strTmp=strTmp+"\r\n	if (dwReason == DLL_PROCESS_ATTACH)";
	strTmp=strTmp+"\r\n	{";
	strTmp=strTmp+"\r\n		DisableThreadLibraryCalls(hModule);";
	strTmp=strTmp+"\r\n";
	strTmp=strTmp+"\r\n		for (INT i = 0; i < sizeof(m_dwReturn) / sizeof(DWORD); i++)";
	strTmp=strTmp+"\r\n		{";
	strTmp=strTmp+"\r\n			m_dwReturn[i] = TlsAlloc();";
	strTmp=strTmp+"\r\n		}";
	strTmp=strTmp+"\r\n		InitAddr();";
	strTmp=strTmp+"\r\n	}";
	strTmp=strTmp+"\r\n	else if (dwReason == DLL_PROCESS_DETACH)";
	strTmp=strTmp+"\r\n	{";
	strTmp=strTmp+"\r\n		for (INT i = 0; i < sizeof(m_dwReturn) / sizeof(DWORD); i++)";
	strTmp=strTmp+"\r\n		{";
	strTmp=strTmp+"\r\n			TlsFree(m_dwReturn[i]);";
	strTmp=strTmp+"\r\n		}";
	strTmp=strTmp+"\r\n";
	strTmp=strTmp+"\r\n		Free();";
	strTmp=strTmp+"\r\n	}";
	strTmp=strTmp+"\r\n";
	strTmp=strTmp+"\r\n	return TRUE;";
	strTmp=strTmp+"\r\n}";
	strTmp=strTmp+"\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////";

	fwrite(strTmp.c_str(),strTmp.size(),1,fp);

	fprintf(fp,
		"\r\n#define VOIDSTD EXTERNC void __stdcall\r\n"
		"#define INT64STD EXTERNC INT64 __stdcall\r\n"
		"INT64STD AsmFunc1();\r\n"
		"VOIDSTD AsmFunc2(INT64 iRcx);\r\n"		
		"\r\n");
	//生成全局指针
	for (it=m_FuncArray.begin();it!=m_FuncArray.end();it++)
	{
		char szTmp[1024] = {0};
		if(it->strFuncName=="NoName")
		{
			wsprintfA(szTmp,"FARPROC g_Noname%d = NULL;\r\n",\
				it->dwFuncXuhao);			
		}
		else
		{
			wsprintfA(szTmp,"FARPROC g_%s = NULL;\r\n",\
				it->strFuncName.c_str());
		}
		fwrite(szTmp,strlen(szTmp),1,fp);
	}
	//生成Init函数
	fprintf(fp,
		"VOID InitAddr()\r\n"
		"{\r\n");
	for (it=m_FuncArray.begin();it!=m_FuncArray.end();it++)
	{
		char szTmp[1024] = {0};
		if(it->strFuncName=="NoName")
		{
			wsprintfA(szTmp,"  g_Noname%d = GetAddress(MAKEINTRESOURCEA(%d));\r\n",\
				it->dwFuncXuhao,it->dwFuncXuhao);			
		}
		else
		{
			wsprintfA(szTmp,"  g_%s = GetAddress(\"%s\");\r\n",\
				it->strFuncName.c_str(),it->strFuncName.c_str());
		}
		fwrite(szTmp,strlen(szTmp),1,fp);
	}
	fprintf(fp,
		"}\r\n");


	for (it=m_FuncArray.begin();it!=m_FuncArray.end();it++)
	{	
		char szTmp[1024] = {0};
		if(it->strFuncName=="NoName")
		{
			wsprintfA(szTmp,"// 导出函数\r\nALCDECL _AheadLib_Noname%d(void)\r\n{\r\n  AsmFunc1();\r\n  AsmFunc2((INT64)g_Noname%d);\r\n}\r\n",\
				it->dwFuncXuhao,it->dwFuncXuhao);			
		}
		else
		{
			wsprintfA(szTmp,"// 导出函数\r\nALCDECL _AheadLib_%s(void)\r\n{\r\n  AsmFunc1();\r\n  AsmFunc2((INT64)g_%s);\r\n}\r\n",\
				it->strFuncName.c_str(),it->strFuncName.c_str());
		}
		fwrite(szTmp,strlen(szTmp),1,fp);
	}
	fclose(fp);
	return TRUE;
}